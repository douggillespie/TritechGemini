package tritechgemini.tritech.ecd;

import java.io.BufferedInputStream;
import java.io.DataInput;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;


public class ECDFile {

	private File ecdFile;

	private boolean fileOk = false;

	private int head_ver;

	private String head_msg;

	private int end_inf;

	private ArrayList<ECDRecordSet> emptyECDRecords = new ArrayList<ECDRecordSet>();

	private int nImage = 0;

	public static final int HEAD_VERSION = 0x0F0F;

	public static final String HEAD_MSG = "Main Data";

	public static final int MASK_DEFAULT = 0x000C;
	public static final int MASK_TIS_QI = 0x01;
	public static final int MASK_TIS_PA = 0x02;
	public static final int MASK_TIS_SCAN = 0x04;
	public static final int MASK_TIS_RB = 0x08;
	public static final int MASK_TIS_TGT = 0x10;
	public static final int MASK_TIS_XYZ = 0x20;
	public static final int MASK_TIS_SHRP = 0x40;
	public static final int MASK_TIS_ = 0x80;

	private long firstFrameTime = Long.MAX_VALUE;
	private long lastFrameTime = Long.MIN_VALUE;

	/**
	 * bitmap of available sonar id's 
	 */
	private int frameBitMap;

	/*
	 * Log files generated by the Gemini Imager will include:
	 * Target Image Records (Type 3, 0xCFCF), 
	 * Ping Tail Ex (Type 4, 0xBFBF) 
	 * and Acoustic Zoom (Type 5, 0xAFAF)
	 */

	/**
	 * Open and start to unpack an ECD file
	 * @param ecdFile
	 */
	public ECDFile(File ecdFile) {
		super();
		this.ecdFile = ecdFile;

		try {
			fileOk = catalogFile(ecdFile);
		} catch (IOException e) {
			System.out.println ("Error decording Gemini file " + e.getMessage() + " " + ecdFile.getAbsolutePath());
			fileOk = false;
		}
	}

	public static long findFirstRecordTime(File ecdFile) {

		if (ecdFile.exists() == false) {
			return -1;
		}
		long fileLength = ecdFile.length();
		long firstTime = -1;
		try {
			FileInputStream fis = new FileInputStream(ecdFile);
			/*
			 * Using a buffered input stream brings down the file read time from 18s to 322 millis (x56 speed up)
			 * i've also tried various combinations of random access files and they are not ideal since they go even 
			 * slower than a basic unbuffered file input stream. 
			 */
			BufferedInputStream bis = new BufferedInputStream(fis);
			CountingInputStream cis = new CountingInputStream(bis);
			DataInput dis = new LittleEndianDataInputStream(cis);
			//		bis.
			//		RandomAccessFile ras = new RandomAccessFile(ecdFile, "r");
			//		DataInput dis = ras;
			//		BufferedInputStream bis = new BufferedInputStream(raf);
			//		DataInput dis = new LEDataInput(ras);
			/*
			 * unsigned short version, version2, Type, Ver, Tag, m_tid, m_pid, m_pid2;
			 * short m_version, m_shading, m_mainGain, m_gainBlank, m_adcInput, m_spreadGain, m_absorbGain, m_bfGain, m_txStart, m_txLen, m_numBeams, m_rx1, m_rx2, m_tx1, m_pingFlags;
			 * double m_txTime, m_endTime, m_txAngle, m_sosAvg;
			 * int m_halfArr, m_bfFocus, m_modFreq, m_b0, m_b1, m_r0, m_r1, sCount;
			 * unsigned int mask, m_nRngs, dual, m_nBrgs, m_nBrgs_2,cSize;
			 * float m_sosAtXd, m_bfAperture, m_txRadius, m_txRng, m_sosAtXd_2;
			 * unsigned char m_pid, m_txLength, m_scanRate, m_rx1Arr, m_rx2Arr, m_tx1Arr, m_tx2Arr, m_bpp;
			 */
			int head_ver = dis.readInt();
			int end_inf = dis.readInt();
			String head_msg = readUnicodeString(dis, 9);
			ECDRecordSet ecdRecord = null;
			int frameNumber = 0;
			while (firstTime < 0) {
				long filePos = cis.getPos();
				int type = dis.readUnsignedShort(); // first record is TARGET_IMAGE_RECORD
				if (type == ECDRecord.END_TAG) {
					break;
				}
				int ver = dis.readUnsignedShort();
				boolean ok = ECDRecord.checkTypeVersion(type, ver);
				if (ok == false) {
					break;
				}
				GeminiTargetImage targetImage;
				switch (type) {
				case ECDRecord.TYPE_SENSOR_RECORD:
//					readSensorRecord(ecdFile, type, ver, dis);
					gotoNextEndTag(dis);
					break;
				//			break;
				//		case TYPE_TARGET_RECORD:
				//			readSensorRecord(ecdFile, type, ver, dis);
				//			break;
				case ECDRecord.TYPE_TARGET_IMAGE_RECORD:
					targetImage = readTargetImageRecord(ecdFile, type, ver, dis);
					firstTime = targetImage.getM_TimeMills();
					//				ecdRecord = new ECDRecordSet(this, filePos, targetImage, frameNumber++);
					//				emptyECDRecords.add(ecdRecord);
					//				ecdRecord.freeImageData();
					//				nImage++;
					//				firstFrameTime = Math.min(firstFrameTime, ecdRecord.getTimeMillis());
					//				lastFrameTime = Math.max(lastFrameTime, ecdRecord.getTimeMillis());
					//				frameBitMap |= 1<<(ecdRecord.getSonar()-1);
					//				if ((nImage%100) == 0) {
					//					System.out.println("Read target image record " + nImage);
					//				}
					break;
				case ECDRecord.TYPE_PING_TAIL_RECORD:
					GeminiPingTail pingTail = readPingTailRecord(ecdFile, type, ver, dis);
					ecdRecord.setPingTail(pingTail);
					break;
				case ECDRecord.TYPE_ACOUSTIC_ZOOM_RECORD:
					GeminiAcousticZoom acousticZoom = readAcousticZoomRecord(ecdFile, type, ver, dis);
					ecdRecord.setAcousticZoom(acousticZoom);
					break;
				default:
					System.err.printf("Unknown gemini record type %d version %d in file %s\n", type, ver, ecdFile.getAbsolutePath());
				}
			}

			fis.close();
		}
		catch(IOException e) {

		}
		return firstTime;
	}

	private boolean catalogFile(File ecdFile) throws IOException {
		if (ecdFile.exists() == false) {
			return false;
		}
		long fileLength = ecdFile.length();
		FileInputStream fis = new FileInputStream(ecdFile);
		/*
		 * Using a buffered input stream brings down the file read time from 18s to 322 millis (x56 speed up)
		 * i've also tried various combinations of random access files and they are not ideal since they go even 
		 * slower than a basic unbuffered file input stream. 
		 */
		BufferedInputStream bis = new BufferedInputStream(fis);
		CountingInputStream cis = new CountingInputStream(bis);
		DataInput dis = new LittleEndianDataInputStream(cis);

		//		bis.
		//		RandomAccessFile ras = new RandomAccessFile(ecdFile, "r");
		//		DataInput dis = ras;
		//		BufferedInputStream bis = new BufferedInputStream(raf);
		//		DataInput dis = new LEDataInput(ras);
		/*
		 * unsigned short version, version2, Type, Ver, Tag, m_tid, m_pid, m_pid2;
		 * short m_version, m_shading, m_mainGain, m_gainBlank, m_adcInput, m_spreadGain, m_absorbGain, m_bfGain, m_txStart, m_txLen, m_numBeams, m_rx1, m_rx2, m_tx1, m_pingFlags;
		 * double m_txTime, m_endTime, m_txAngle, m_sosAvg;
		 * int m_halfArr, m_bfFocus, m_modFreq, m_b0, m_b1, m_r0, m_r1, sCount;
		 * unsigned int mask, m_nRngs, dual, m_nBrgs, m_nBrgs_2,cSize;
		 * float m_sosAtXd, m_bfAperture, m_txRadius, m_txRng, m_sosAtXd_2;
		 * unsigned char m_pid, m_txLength, m_scanRate, m_rx1Arr, m_rx2Arr, m_tx1Arr, m_tx2Arr, m_bpp;
		 */
		long firstFrameTime = -1;
		this.head_ver = dis.readInt();
		this.end_inf = dis.readInt();
		this.head_msg = readUnicodeString(dis, 9);
		ECDRecordSet ecdRecord = null;
		int frameNumber = 0;
		while (true) {
			long filePos = cis.getPos();
			int type = dis.readUnsignedShort(); // first record is TARGET_IMAGE_RECORD
			if (type == ECDRecord.END_TAG) {
				break;
			}
			int ver = dis.readUnsignedShort();
//			System.out.printf("Reading type %d version %d\n", type, ver);
			boolean ok = ECDRecord.checkTypeVersion(type, ver);
			if (ok == false) {
				break;
			}
			GeminiTargetImage targetImage;
			switch (type) {
			case ECDRecord.TYPE_SENSOR_RECORD:
//				readSensorRecord(ecdFile, type, ver, dis);
				gotoNextEndTag(dis);
				break;
//			case TYPE_TARGET_RECORD:
//				readSensorRecord(ecdFile, type, ver, dis);
//				break;
			case ECDRecord.TYPE_TARGET_IMAGE_RECORD:
				targetImage = readTargetImageRecord(ecdFile, type, ver, dis);
				ecdRecord = new ECDRecordSet(this, filePos, targetImage, frameNumber++);
				emptyECDRecords.add(ecdRecord);
				ecdRecord.freeImageData();
				nImage++;
				firstFrameTime = Math.min(firstFrameTime, ecdRecord.getTimeMillis());
				lastFrameTime = Math.max(lastFrameTime, ecdRecord.getTimeMillis());
				frameBitMap |= 1<<(ecdRecord.getSonar()-1);
				//				if ((nImage%100) == 0) {
				//					System.out.println("Read target image record " + nImage);
				//				}
				break;
			case ECDRecord.TYPE_PING_TAIL_RECORD:
				GeminiPingTail pingTail = readPingTailRecord(ecdFile, type, ver, dis);
				ecdRecord.setPingTail(pingTail);
				break;
			case ECDRecord.TYPE_ACOUSTIC_ZOOM_RECORD:
				GeminiAcousticZoom acousticZoom = readAcousticZoomRecord(ecdFile, type, ver, dis);
				ecdRecord.setAcousticZoom(acousticZoom);
				break;
			default:
				System.err.printf("Unknown gemini record type %d version %d in file %s\n", type, ver, ecdFile.getAbsolutePath());
			}
		}


		fis.close();
		return true;
	}

	/**
	 * work through file byte at a time until next endflag is found. These occurr at
	 * end of every record. 
	 * @param dis
	 */
	private static int gotoNextEndTag(DataInput dis) {
		int prevByte = 0;int nRead = 0;
		try {
			while (true) {
				int aByte = dis.readUnsignedByte();
				nRead++;
				if (aByte == ECDRecord.HALF_END_TAG && prevByte == ECDRecord.HALF_END_TAG) {
					break;
				}
				prevByte = aByte;
			}

		} catch (IOException e) {
			System.out.println("Error in ECD gogNextEndTag: " + e.getLocalizedMessage());
		}
		return nRead;
	}

//	private static void readSensorRecord(File ecdFile2, int type, int ver, DataInput dis) {
//		/*
//		 * In example file, next record is clearly starting after 35 bytes, but nothing is making a lot
//		 * of sense with the CString part. According to spec doc, after the type and ver there should
//		 * be 13 bytes apart from the CString, so the CString should be 22 bytes long. The actual string 
//		 * seems to be "chirp: 1" which is 8 characters, poss 9 if there is a trailing space.  
//		 */
//		try {
//			int m_type = dis.readUnsignedByte();
//			int dum = dis.readUnsignedShort();
//			int m_blank = dis.readUnsignedByte();
//			dis.skipBytes(2);
//			int strLen = dis.readUnsignedByte();
////			for (int i = 0; i < strLen; i++) {
////				char c  = dis.readChar();
////				System.out.printf(""+c);
////				if ((i%100) == 0) {
////					System.out.printf("\n");
////				}
////			}
////			System.out.printf("\n");
//			String str = readUnicodeString(dis, strLen);
////			String str = dis.readUTF();
//			short msgStatus = dis.readShort();
//			double m_time = dis.readDouble();
//			
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//		
//	}

	public boolean fullReadRecordSet(ECDRecordSet ecdRecordSet) throws IOException {
		FileInputStream fis = new FileInputStream(ecdFile);
		BufferedInputStream bis = new BufferedInputStream(fis);
		CountingInputStream cis = new CountingInputStream(bis);
		DataInput dis = new LittleEndianDataInputStream(cis);
		int skipped = dis.skipBytes((int) ecdRecordSet.getFilePosition());
		// should be exactly before the start of the three records, so loop through 
		while (ecdRecordSet.isComplete() == false) {
			//			long filePos = cis.getPos();
			int type = dis.readUnsignedShort(); // first record is TARGET_IMAGE_RECORD
			if (type == ECDRecord.END_TAG) {
				break;
			}
			int ver = dis.readUnsignedShort();
			boolean ok = ECDRecord.checkTypeVersion(type, ver);
			if (ok == false) {
				break;
			}
			GeminiTargetImage targetImage;
			switch (type) {
			case ECDRecord.TYPE_TARGET_IMAGE_RECORD:
				targetImage = readTargetImageRecord(ecdFile, type, ver, dis);
				ecdRecordSet.setTargetImage(targetImage);
				break;
			case ECDRecord.TYPE_PING_TAIL_RECORD:
				GeminiPingTail pingTail = readPingTailRecord(ecdFile, type, ver, dis);
				ecdRecordSet.setPingTail(pingTail);
				break;
			case ECDRecord.TYPE_ACOUSTIC_ZOOM_RECORD:
				GeminiAcousticZoom acousticZoom = readAcousticZoomRecord(ecdFile, type, ver, dis);
				ecdRecordSet.setAcousticZoom(acousticZoom);
				break;
			default:
				System.err.printf("Unknown gemini record type %d version %d in file %s\n", type, ver, ecdFile.getAbsolutePath());
			}
		}

		fis.close();

		return true;
	}

	private static GeminiTargetImage readTargetImageRecord(File ecdFile, int type, int ver, DataInput dis) throws IOException {
		GeminiTargetImage targetImage = new GeminiTargetImage(ecdFile, type, ver);
		boolean ok = targetImage.readDataFile(dis);
		if (ok) {
			return targetImage;
		}
		else {
			return null;
		}
	}

	private static  GeminiPingTail readPingTailRecord(File ecdFile, int type, int ver, DataInput dis) throws IOException {
		GeminiPingTail pingTail = new GeminiPingTail(ecdFile, type, ver);
		boolean ok = pingTail.readDataFile(dis);
		return ok ? pingTail : null;

	}

	private static GeminiAcousticZoom readAcousticZoomRecord(File ecdFile, int type, int ver, DataInput dis)  throws IOException {
		GeminiAcousticZoom acousticZoom = new GeminiAcousticZoom(ecdFile, type, ver);
		boolean ok = acousticZoom.readDataFile(dis);
		return ok ? acousticZoom : null;
	}

	private String readByteString(DataInput dis, int nChar) throws IOException {
		byte[] bytes = new byte[nChar];
		dis.readFully(bytes);
		return new String(bytes, Charset.forName("UTF_8"));
	}
	
//	private statis String readCString(DataInout dis) throws UIExce

	private static String readUnicodeString(DataInput dis, int nChar) throws IOException {
		byte[] bytes = new byte[nChar*2];
		dis.readFully(bytes);
		return new String(bytes, Charset.forName("UTF_16LE"));
	}

	/**
	 * Keep reading until we get a null. 
	 * @param dis
	 * @return
	 * @throws IOException
	 */
	private String readUnicodeCString(DataInput dis) throws IOException {
		String str = "";
		//		Charset charset = Charset.forName("UTF_16LE");
		while (true) {
			int ch1 = dis.readByte();
			int ch2 = dis.readByte();
			if (ch1 == 0) {
				break;
			}
			str += ch1;
		}

		return str;
	}


	/**
	 * @return the nImage
	 */
	public int getnImage() {
		return nImage;
	}

	/**
	 * @return the emptyECDRecords
	 */
	public ArrayList<ECDRecordSet> getEmptyECDRecords() {
		return emptyECDRecords;
	}

	/**
	 * @return the fileOk
	 */
	public boolean isFileOk() {
		return fileOk;
	}

	/**
	 * @return the firstFrameTime
	 */
	public long getFirstFrameTime() {
		return firstFrameTime;
	}

	/**
	 * @return the lastFrameTime
	 */
	public long getLastFrameTime() {
		return lastFrameTime;
	}

	/**
	 * @return the frameBitMap
	 */
	public int getFrameBitMap() {
		return frameBitMap;
	}
}
